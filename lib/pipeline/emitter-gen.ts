import { RgsoModel } from './types';

export function generateEmitterTs(model: RgsoModel): string {
  const entries = model.blocks.map(b => `    ${JSON.stringify(model.grammarName + ':' + b.altName)}: ${JSON.stringify(b, null, 2).replace(/\n/g, '\n    ')}`).join(',\n');
  return `// Auto-generated RDF emitter for ${model.grammarName}\n\nexport type IRI = string;\nexport type Lang = string;\nexport interface Literal { lex: string; lang?: Lang; datatype?: IRI }\nexport type Term = { type: 'iri'; value: IRI } | { type: 'bnode'; id: string } | { type: 'literal'; value: Literal };\nexport type Triple = { s: Term; p: Term; o: Term; g?: Term };\n\nexport interface Context {\n  getByPath(ctx: any, path: string): any;\n  toIri(node: any): IRI;\n  toLiteral(node: any): Literal;\n  bnode(idHint?: string): Term;\n  resolvePrefixOf?(curie: string): IRI;\n  expandPO?(node: any): Array<{P:any,O:any}>;\n  collectTriples?(node: any): Array<{S:any,P:any,O:any}>;\n  explodeTriples?(node: any): Array<{S:any,P:any,O:any}>;\n}\n\ninterface Binding { var: string; path: string; transform?: string }\ninterface TermTpl { kind: 'iri'|'literal'|'bnode'; value?: string; fromVar?: string; lang?: string; datatype?: string; transform?: string }\ninterface EmitTpl { subject: TermTpl; predicate: TermTpl; object: TermTpl; graph?: TermTpl }\ninterface Block { altName: string; prefixes: Record<string,string>; defaultLang?: string; defaultDatatype?: string; terms: Record<string,TermTpl>; bindings: Binding[]; emits: EmitTpl[] }\n\nconst TABLE: Record<string, Block> = {\n${entries}\n};\n\nfunction expandCurie(raw: string, block: Block, ctx: Context): string {\n  if (/^[A-Za-z_][A-Za-z0-9_]*:[A-Za-z0-9_.-]+$/.test(raw) && !raw.includes('://')) {\n    const [pfx, local] = raw.split(':',2);\n    const base = block.prefixes[pfx] ?? (ctx.resolvePrefixOf ? ctx.resolvePrefixOf(pfx) : undefined);\n    if (base) return base + local;\n  }\n  return raw;\n}\n\nfunction makeTerm(t: TermTpl, vars: Record<string, any>, ctx: Context, block: Block): Term {\n  switch (t.kind) {\n    case 'iri': {\n      let v: any = t.value ?? (t.fromVar ? vars[t.fromVar] : undefined);\n      if (typeof v !== 'string') v = ctx.toIri(v);\n      v = expandCurie(v, block, ctx);\n      return { type: 'iri', value: v };\n    }\n    case 'bnode': {\n      const id = t.value ?? (t.fromVar ? String(vars[t.fromVar]) : undefined);\n      return ctx.bnode(id);\n    }\n    case 'literal': {\n      const val: any = t.value ?? (t.fromVar ? vars[t.fromVar] : undefined);\n      if (typeof val === 'string') return { type: 'literal', value: { lex: val, lang: t.lang, datatype: t.datatype } };\n      const lit = ctx.toLiteral(val);\n      return { type: 'literal', value: { lex: lit.lex, lang: t.lang ?? lit.lang, datatype: t.datatype ?? lit.datatype } };\n    }\n  }\n}\n\nexport function createEmitter() {\n  function evalBlock(block: Block, ctxNode: any, ctx: Context): Triple[] {\n    const vars: Record<string, any> = {};\n    for (const b of block.bindings) vars[b.var] = ctx.getByPath(ctxNode, b.path);\n    for (const [k, t] of Object.entries(block.terms)) vars[k] = (t as any).value ?? (t as any).fromVar ?? null;\n    const triples: Triple[] = [];\n    for (const e of block.emits) {\n      const s = makeTerm(e.subject, vars, ctx, block);\n      const p = makeTerm(e.predicate, vars, ctx, block);\n      const o = makeTerm(e.object, vars, ctx, block);\n      const g = e.graph ? makeTerm(e.graph, vars, ctx, block) : undefined;\n      triples.push({ s, p, o, g });\n    }\n    return triples;\n  }\n  return { onAlt(qualifiedAlt: string, ctxNode: any, ctx: Context) {\n    const block = (TABLE as any)[qualifiedAlt] as Block;\n    if (!block) return [];\n    return evalBlock(block, ctxNode, ctx);\n  }};\n}\n`;
}
